#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is simply a bridge application for Lifx bulbs.
# 
# Copyright (c) 2016 Fran√ßois Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy 
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE

import argparse, sys, traceback,json,logging,functools,random,os,ssl,math, colorsys
import buddylib as bl
import asyncio as aio
import aiolifx
from functools import partial

SUBTYPE="Lifx"
CERTFILE="autobuddy.crt"
__version__="0.10"

UDP_BROADCAST_PORT = 56700

def intround(x):
    return int(round(x))

#<controlgroup modal="1" name="colour" label="Colour" widget="colourpicker">
lifx_functions="""
<buddyui version="0.1">
    <command name="lifx">
        <controlgroup type="list" name="power" label="Power" rteffect="1">
            <control type="switch" name="power" label="Power" rteffect="1">
                <value label="On">on</value>
                <value label="Off">off</value>
            </control>
            <control type="spinner" name="duration" label="Duration"  >
                <start>0</start>
                <end>600</end>
                <increment>1</increment>
                <postfix>secs</postfix>
                <default>0</default>
            </control>
        </controlgroup>
        <controlgroup type="list" name="colour" label="Colour" rteffect="1">
            <controlgroup type="list" name="colour" label="Colour" widget="colourpicker" rteffect="1">
                <control type="slider" name="hue" label="Hue" rteffect="1">
                    <start>0</start>
                    <end>360</end>
                    <increment>1</increment>
                </control>
                <control type="slider" name="saturation" label="Saturation" rteffect="1">
                    <start>0</start>
                    <end>100</end>
                    <increment>1</increment>
                </control>
                <control type="slider" name="value" label="Brightness" rteffect="1">
                    <start>0</start>
                    <end>100</end>
                    <increment>1</increment>
                </control>
            </controlgroup>
            <control type="spinner" name="duration" label="Duration"  >
                <start>0</start>
                <end>600</end>
                <increment>1</increment>
                <postfix>secs</postfix>
                <default>0</default>
            </control>
        </controlgroup>
        <controlgroup  type="list" name="white" label="White">
            <control type="slider" name="value" label="Brightness" rteffect="1">
                <start>0</start>
                <end>100</end>
                <increment>1</increment>
            </control>
            <control type="slider" name="temperature" label="Kelvin" rteffect="1">
                <start>2500</start>
                <end>9000</end>
                <increment>100</increment>
            </control>
            <control  type="spinner" name="duration" label="Duration">
                <start>0</start>
                <end>600</end>
                <increment>1</increment>
                <postfix>secs</postfix>
                <default>0</default>
            </control>
        </controlgroup>
        <controlgroup  type="grouplist" name="pulse" label="Pulse" rteffect="1">
            <control type="switch" name="transient" label="End Colour" rteffect="1">
                <value label="Old">on</value>
                <value label="New">off</value>
            </control>
            <controlgroup type="list" name="colour" label="Colour" widget="colourpicker" rteffect="1">
                <control type="slider" name="hue" label="Hue" rteffect="1">
                    <start>0</start>
                    <end>360</end>
                    <increment>1</increment>
                </control>
                <control type="slider" name="saturation" label="Saturation" rteffect="1">
                    <start>0</start>
                    <end>100</end>
                    <increment>1</increment>
                </control>
                <control type="slider" name="value" label="Brightness" rteffect="1">
                    <start>0</start>
                    <end>100</end>
                    <increment>1</increment>
                </control>
            </controlgroup>
            <control type="spinner" name="duration" label="Duration" rteffect="1">
                <start>0.01</start>
                <end>300</end>
                <increment>0.1</increment>
                <decimals>2</decimals>
                <default>1.0</default>
            </control>
            <control type="spinner" name="repeat" label="Repeat" rteffect="1">
                <start>1</start>
                <increment>1</increment>
            </control>
            <control  type="slider" name="balance" label="Balance">
                <start>-50</start>
                <end>50</end>
                <increment>1</increment>
                <default>0</default>
            </control>
            <controlgroup type="choice" name="type" label="Type">
                <item value="0" label="Saw" />
                <item value="1" label="Sine" />
                <item value="2" label="Half Sine" />
                <item value="3" label="Triangle" />
                <item value="4" label="Pulse" />
            </controlgroup>
        </controlgroup>
    </command>
</buddyui>
"""

lifx_config="""
<buddyui version="0.1">
    <configuration  name="lifx">
        <control type="spinner" name="refresh" label="Check for new devices interval">
            <start>30</start>
            <end>3600</end>
            <increment>1</increment>
            <postfix>secs</postfix>
            <default>180</default>
        </control>
        <control type="spinner" name="heartbeat" label="Requesting status from lightbulbs">
            <start>10</start>
            <end>600</end>
            <increment>10</increment>
            <postfix>secs</postfix>
            <default>60</default>
        </control>
    </configuration>
</buddyui>
"""
lifx_config_default={"refresh":120,"heartbeat":60}

def convert_K_to_RGB(colour_temperature):
    """
    Converts from K to RGB, algorithm courtesy of 
    http://www.tannerhelland.com/4435/convert-temperature-rgb-algorithm-code/
    Taken from petrklus on github
    """
    #range check
    if colour_temperature < 1000: 
        colour_temperature = 1000
    elif colour_temperature > 40000:
        colour_temperature = 40000
    
    tmp_internal = colour_temperature / 100.0
    
    # red 
    if tmp_internal <= 66:
        red = 255
    else:
        tmp_red = 329.698727446 * math.pow(tmp_internal - 60, -0.1332047592)
        if tmp_red < 0:
            red = 0
        elif tmp_red > 255:
            red = 255
        else:
            red = int(tmp_red+0.5)
    
    # green
    if tmp_internal <=66:
        tmp_green = 99.4708025861 * math.log(tmp_internal) - 161.1195681661
        if tmp_green < 0:
            green = 0
        elif tmp_green > 255:
            green = 255
        else:
            green = int(tmp_green+0.5)
    else:
        tmp_green = 288.1221695283 * math.pow(tmp_internal - 60, -0.0755148492)
        if tmp_green < 0:
            green = 0
        elif tmp_green > 255:
            green = 255
        else:
            green = int(tmp_green+0.5)
    
    # blue
    if tmp_internal >=66:
        blue = 255
    elif tmp_internal <= 19:
        blue = 0
    else:
        tmp_blue = 138.5177312231 * math.log(tmp_internal - 10) - 305.0447927307
        if tmp_blue < 0:
            blue = 0
        elif tmp_blue > 255:
            blue = 255
        else:
            blue = int(tmp_blue+0.5)
    return (red, green, blue)

def lifx_process(self,msg):
    if not self.present:
        return None
    try:
        if msg["content_type"] == "command":
            if "realtime mode" in msg["content"] and msg["content"]["realtime mode"]:
                rapidfire = True
            else:
                rapidfire = False
            if msg["content"]["command"] == "power":                
                mypartial=partial(self.controller.sending,
                                {"subject":self.controller.type,
                                "content_type":"event",
                                "content": {"event":"power",
                                            "target": self.controller.type + "." + self.name,
                                            "icon status" : {"bu-fill":{"fill":(msg["content"]["value"]["power"]=="on" and self.cssColour(force=True)) or "transparent"}},
                                            "value":msg["content"]["value"]}})
                if "duration" in msg["content"]["value"] and msg["content"]["value"]["duration"]:
                    self.conn.set_power((msg["content"]["value"]["power"]=="on" and 1) or 0,duration=1000*int(msg["content"]["value"]["duration"] or 0),
                                        callb=lambda x,y: mypartial())
                else:
                    self.conn.set_power((msg["content"]["value"]["power"]=="on" and 1) or 0,callb=lambda x,y: mypartial())
                    
            elif msg["content"]["command"] == "colour":
                mypartial=partial(self.controller.sending,{"subject":self.controller.type,
                                "content_type":"event",
                                "content": {"event":"colour",
                                            "target": self.controller.type + "." + self.name,
                                            "icon status" : {"bu-fill":{"fill":self.cssColour(
                                                    [intround((float(msg["content"]["value"]["hue"])*65535.0)/360.0),
                                                     intround((float(msg["content"]["value"]["saturation"])*65535.0)/100.0),
                                                     intround((float(msg["content"]["value"]["value"])*65535.0)/100.0),3500])}},
                                            "value":msg["content"]["value"]}})
                if "duration" in msg["content"]["value"] and msg["content"]["value"]["duration"]:
                    self.conn.set_color([intround((float(msg["content"]["value"]["hue"])*65535.0)/360.0),
                                        intround((float(msg["content"]["value"]["saturation"])*65535.0)/100.0),
                                        intround((float(msg["content"]["value"]["value"])*65535.0)/100.0),3500], 
                                        duration=int(msg["content"]["value"]["duration"] or 0)*1000, callb=lambda x,y: mypartial(),rapid=rapidfire)
                else:    
                    self.conn.set_color([intround((float(msg["content"]["value"]["hue"])*65535.0)/360.0),
                                        intround((float(msg["content"]["value"]["saturation"])*65535.0)/100.0),
                                        intround((float(msg["content"]["value"]["value"])*65535.0)/100.0),3500], callb=lambda x,y: mypartial(),rapid=rapidfire)

            elif msg["content"]["command"] == "white":
                mypartial=partial(self.controller.sending,{"subject":"",
                                "content_type":"event",
                                "content": {"event":"white",
                                            "target": self.controller.type + "." + self.name,
                                            "icon status" : {"bu-fill":{"fill":self.cssColour([58275,0,
                                                    intround((float(msg["content"]["value"]["value"])*65365.0)/100.0),
                                                    intround(float(msg["content"]["value"]["temperature"]))])}},
                                            "value":msg["content"]["value"]}})
                if "duration" in msg["content"]["value"] and msg["content"]["value"]["duration"]:
                    self.conn.set_color([58275,0,
                                        intround((float(msg["content"]["value"]["value"])*65365.0)/100.0),
                                        intround(float(msg["content"]["value"]["temperature"]))], duration=int(msg["content"]["value"]["duration"] or 0)*1000,
                                        callb=lambda x,y: mypartial(),rapid=rapidfire)
                else:
                    self.conn.set_color([58275,0,
                                        intround((float(msg["content"]["value"]["value"])*65365.0)/100.0),
                                        intround(float(msg["content"]["value"]["temperature"]))], callb=lambda x,y: mypartial(),rapid=rapidfire)
                    
            elif msg["content"]["command"] == "pulse":
                startcss=self.cssColour(force=True)
                endcss = self.cssColour(col=[intround((float(msg["content"]["value"]["colour"]["hue"])*65535.0)/360.0),
                                             intround((float(msg["content"]["value"]["colour"]["saturation"])*65535.0)/100.0),
                                             intround((float(msg["content"]["value"]["colour"]["value"])*65535.0)/100.0),3500])
                trans = ("transient" in msg["content"]["value"] and msg["content"]["value"]["transient"]=="on") or 1
                dur = int(float(msg["content"]["value"]["duration"])*1000)
                repeat=int(msg["content"]["value"]["repeat"])
                if trans:
                    anim="@keyframes flash"+self.name+" {  0% { fill: "+startcss+" }  50% { fill: "+endcss+" }  100% { fill: "+startcss+" }}"
                    alen=dur
                    arep=repeat
                else:
                    anim="@keyframes flash"+self.name+" {  0% { fill: "+startcss+" }  33% { fill: "+endcss+" }  66% { fill: "+startcss+" } 100% { fill: "+endcss+" }}"
                    alen=intround(dur*1.5)
                    arep=intround(repeat/1.5) or 1
                astyle={"animation-name": "flash"+self.name, "animation-duration:":"%dms"%alen, "animation-iteration-count": "%d"%(arep)}
                
                mypartial=partial(self.controller.sending,{"subject":self.controller.type,
                                "content_type":"event",
                                "content": {"event":"pulse",
                                            "target": self.controller.type + "." + self.name,
                                            "icon status" : {"bu-fill":astyle,"animation":anim},
                                            "value":msg["content"]["value"]}})
                 
                self.conn.set_waveform({ "color":[intround((float(msg["content"]["value"]["colour"]["hue"])*65535.0)/360.0),
                                                  intround((float(msg["content"]["value"]["colour"]["saturation"])*65535.0)/100.0),
                                                  intround((float(msg["content"]["value"]["colour"]["value"])*65535.0)/100.0),3500],
                                         "transient": trans, "period": dur,
                                         "cycles":repeat, "duty_cycle":intround((32767*int(msg["content"]["value"]["balance"]))/50.0),
                                         "waveform":msg["content"]["value"]["type"]["bu-cvalue"]}, callb=lambda x,y: mypartial())

            elif msg["content"]["command"] == "status":
                current=self.conn and ((self.conn.power_level and "on" ) or "off")
                if current:
                    #Not gone the way of the dodo
                    colour=self.conn.color
                
                    #try:
                    self.controller.sending({"subject":self.controller.type,
                                        "content_type":"event",
                                        "content": {"event":"status",
                                                    "target": self.controller.type + "." + self.name,
                                                    "icon status" : {"bu-fill":{"fill":self.cssColour()},"bu-not-present":{"opacity":0}},
                                                    "value":{"power":{"power":current},
                                                            "colour":{"hue": (360.0*colour[0])/65365.0,
                                                                    "saturation":(100.0*colour[1])/65365.0,
                                                                    "value": (100.0*colour[2])/65365.0},
                                                            "white":{ "value": (100.0*colour[2])/65365.0,
                                                                    "temperature":colour[3]}}}})
                    #except:
                        #self.sending({"subject":self.controller.type,
                                    #"content_type": "event",
                                    #"content":{"event":"presence", 
                                                #"target": self.controller.type + "." + self.name,
                                                #"value":"offline"}})
                else:
                    self.controller.sending({"subject":self.controller.type,
                                "content_type": "event",
                                "content":{"event":"presence", 
                                        "target": self.controller.type + "." + self.name,
                                        "value":"offline",
                                        "icon status" : {"bu-fill":{"fill":"transparent"}}}})
                                
            elif msg["content"]["command"] == "nickname":
                #print msg
                mypartial=partial(self.controller.sending,{"subject":"control" + "." + self.name,
                        "content_type": "request",
                        "content":{"request":"nickname", 
                                    "target": self.controller.type+"."+ self.name,
                                    #"token": self.controller.target,
                                    "value":{"name":self.name,"nickname": msg["content"]["value"]}}})
                self.conn.set_label(msg["content"]["value"],callb=lambda x,y:mypartial())
                
                
            elif msg["content"]["command"] == "deletion":
                self.controller.sending({"subject":"control" + "." + self.controller.type,
                        "content_type": "request",
                        "content":{"request":"deletion", 
                                    "target": self.controller.type,
                                    "value":self.name}})
        
    except Exception as e:
        bridgectl.log.warning("Bloody process problem",exc_info=(type(e), e, e.__traceback__))

        
    return None


def lighthb(self,duration=30):
    try: #Could happen that conn is None... Maybe a race condition with unregister
        self.conn.get_color(callb=self.sendStatus)
        self.controller.lifxhb[self.name]=self.controller.loop.call_later(duration, partial(self.lighthb,self.controller.lifx_config["heartbeat"]))
    except:
        pass


def sendStatus(self,lifx=None,resp=None):
    #Can be used in callback
    try:
        colour=self.conn.color                        
        self.controller.sending({"subject":self.controller.type,
                        "content_type":"event",
                        "content": {"event":"status",
                                    "target": self.controller.type + "." + self.name,
                                    "icon status" : {"bu-fill":{"fill":self.cssColour()},"bu-not-present":{"opacity":0}},
                                    "value":{"power":{"power":self.conn.power_level and "on" or "off"},
                                            "colour":{"hue": (360.0*colour[0])/65365.0,
                                                    "saturation":(100.0*colour[1])/65365.0,
                                                    "value": (100.0*colour[2])/65365.0},
                                            "white":{ "value": (100.0*colour[2])/65365.0,
                                                    "temperature":colour[3]}}}})
    except:
        self.log.warning("Ooops could not send status",exc_info=(type(e), e, e.__traceback__))
        
        
def cssColour(self, col=None, force=False):
    #try:
    if col:
        colour=col
    else:
        colour=self.conn.color
    if force or col or self.conn.power_level:
        if (100.0*colour[1])/65365.0 > 1 :
            iconsts='#%02x%02x%02x' % tuple(map(lambda x: int((x*255)+0.5),colorsys.hsv_to_rgb((1.0*colour[0])/65365.0,(1.0*colour[1])/65365.0,(1.0*colour[2])/65365.0)))
        else:
            iconsts='#%02x%02x%02x' % convert_K_to_RGB(colour[3])
    else:
        iconsts="transparent"
    return iconsts
    #except:
        #return "white"
        

#Hop we go....
bl.light._process=lifx_process
bl.light.sendStatus=sendStatus
bl.light.lighthb=lighthb
bl.light.cssColour=cssColour
        

class LifxBridge(bl.BuddyBridge):
    """
    This is the bridge application. It will check for the current list  of lifx bulb.
    It will report any new bulb
    """
    def __init__(self,loop,future,config,log):
        super(LifxBridge, self).__init__(loop,future,config,log)
        self.probelights = None
        self.lifxhb={}
        self.lifx_config = lifx_config_default


    def process_command(self,msg):
        if msg["content"]["command"] == "update config":
            if msg["content"]["target"] == self.target:
                for k,v in msg["content"]["value"].items():
                    lifx_config_default[k]=v
                    if k == "refresh":
                        print("Setting  interval on {}".format(dir(fac)))
                        self.probelights.discovery_interval=v
                
                self.sending({"subject":"control" + "." + self.subtype,
                                    "content_type": "request",
                                    "content": {"request":"save configuration",
                                                "target":self.type,
                                                #"token": self.target,
                                            "value":bl.encrypt(lifx_config_default,self.config["buddykey"])}})
        else:
            for aconn in self.devices:
                aconn.process(msg)

    def process_response(self,msg):
        #if msg["content"]["token"] != self.target:
            #if self.log:
                #self.log.warning("Token not matching {} vs {}".format(msg["content"]["token"],self.target))
            #else:
                #print ("Token not matching {} vs {}".format(msg["content"]["token"],self.target))
        if self.state == "init" and msg["content"]["response"] == "configuration" and msg["subject"] == self.target:
            #Getting the config
            newconfig={}
            fromconfig=[]
            if msg["content"]["configuration"]:
                try:
                    storedconfig=bl.decrypt(msg["content"]["configuration"],self.config["buddykey"])
                    if self.config["debug"]:
                        self.log.debug("The config stored is {}".format(storedconfig))
                except:
                    storedconfig={}
                    savenew=True
                    #log
                    if self.log:
                        self.log.warning("Config is mangled")
                    else:
                        print("Config is mangled")

                for x in storedconfig:
                    self.lifx_config[x]=storedconfig[x]
                    if x=="refresh":
                        aiolifx.DISCOVERY_INTERVAL=self.lifx_config[x]
            
            self.config["database"]= msg["content"]["database"]
            if "configonly" in self.config and self.config["configonly"]:
                self.state = "wait config save"
            else:
                self.state = "active"
                self.build()
                self.sending({"subject":"control" + "." + self.target ,
                        "content_type": "request",
                        "content":{"request":"functions", 
                                    "target":self.type,
                                    "subtype": self.subtype,
                                    #"token": self.target,
                                    "value":{"configs":[lifx_config,lifx_config_default]}}})
                self.sending({"subject":self.target ,
                        "content_type": "event",
                        "content":{"event":"config updated", 
                                    "target":self.target,
                                    "value":lifx_config_default}})
            #if savenew or ("configonly" in self.config and self.config["configonly"]):
                #self.sending({"subject":"control" + "." + self.subtype,
                                #"content_type": "request",
                                #"content": {"request":"save configuration",
                                            #"target":self.target,
                                            #"token": self.target,
                                            #"value":bl.encrypt(newconfig,self.config["buddykey"])}})
                                
        elif msg["content"]["response"] == "save configuration" and msg["subject"] == self.target:
            if self.state == "active" and  msg["content"]["status"] != "done":
                #log
                if self.log:
                    self.log.warning("Warning: Configuration was not saved.")
                else:
                    print("Warning: Configuration was not saved.")
            elif self.state == "wait config save":
                if msg["content"]["status"] == "done":
                    raise bl.Exit(0,"Configuration was saved")
                else:
                    raise bl.Exit(2,"Error: Configuration was not saved")
            else:
                self.sending({"subject":"control" + "." + self.target ,
                        "content_type": "request",
                        "content":{"request":"functions", 
                                    "target":self.type,
                                    "subtype": self.subtype,
                                    #"token": self.target,
                                    "value":{"configs":[lifx_config,lifx_config_default]}}})
                self.sending({"subject":self.target ,
                        "content_type": "event",
                        "content":{"event":"config updated", 
                                    "target":self.target,
                                    "value":lifx_config_default}})


        elif self.state == "active":
            if msg["content"]["response"] == "creation" and msg["content"]["status"] == "done":
                sess=bl.getSession(self.config["database"])
                light=sess.query(bl.light).filter_by(name=msg["subject"].split(".")[-1]).one()
                self.sending({"subject":self.type,
                            "content_type": "event",
                            "content":{"event":"new device", 
                                "target":self.type + "." + light.name,
                                "value":{"type":self.type,"subtype":self.subtype,
                                        "name":light.name,"nickname":light.nickname}}})
                bidx=0
                notseen=True
                for b in  self.pending:
                    if b.name == light.name:
                        light.conn = b 
                        light.present=True
                        self.devices.append(light)
                        self.pending = self.pending[:bidx] + self.pending[bidx+1:]
                        self.sending({"subject":self.type,
                                    "content_type": "event",
                                    "content":{"event":"presence", 
                                               "target":self.type + "." + light.name,
                                               "value":"online",
                                               "icon status" : {"bu-fill":{"fill":light.cssColour()},
                                                                "bu-not-present":{"opacity":0}}}})
                        light.conn.get_color(callb=partial(self.newbulb))
                        notseen=False
                        break
                    bidx+=1
                if notseen:
                    self.sending({"subject":self.type,
                                "content_type": "event",
                                "content":{"event":"presence", 
                                           "target":self.type + "." + light.name,
                                           "value":"offline",
                                            "icon status" : {"bu-fill":{"fill":"transparent"},
                                                             "bu-not-present":{"opacity":1}}}})
                sess.close()
            elif msg["content"]["response"] == "nickname" :
                if msg["content"]["status"] == "done":
                    if self.log:
                        self.log.debug (msg)
                    for light in self.devices:
                        if light.name==msg["subject"].split(".")[-1]:
                            light.nickname=msg["content"]["value"] 
                            self.sending({"subject":self.type,
                                    "content_type": "event",
                                    "content":{"event":"nickname",  
                                               "target":self.type + "." + light.name,
                                               "value":light.nickname}})
                            break
                        
            elif msg["content"]["response"] == "deletion" :
                if msg["content"]["status"] == "done":
                    if self.log:
                        self.log.debug (msg)
                    sidx=0
                    doremove=False
                    for light in self.devices:
                        if light.name==msg["subject"].split(".")[-1]:
                            light.conn.transport.close()
                            self.sending({"subject":self.type,
                                    "content_type": "event",
                                    "content":{"event":"deletion",  
                                               "target":self.type + "." + light.name,
                                               "value":light.name}})
                            doremove=True
                            break
                        sidx+=1
                        
                    if doremove:
                        del self.devices[sidx]
        else:
            if self.log:
                self.log.warning("Unknown response {} {} {}".format(msg["subject"] ,msg["content_type"] ,msg["content"])) 
            else:
                print ("Unknown response {} {} {}".format(msg["subject"] ,msg["content_type"] ,msg["content"])) 


                                    
    def build(self):
        sess=bl.getSession(self.config["database"])
        self.sending({"subject":"control" + "." + self.target ,
                "content_type": "request",
                "content":{"request":"functions", 
                            "target":self.type,
                            "subtype": self.subtype,
                            #"token": self.target,
                            "value":{"functions":lifx_functions,"configs":[lifx_config,lifx_config_default]}}})

        self.devices=sess.query(bl.light).filter_by(subtype=self.subtype).all()
        for light in self.devices:
            light.present=False
            self.sending({"subject":self.type,
                "content_type": "event",
                "content":{"event":"presence", 
                           "target":self.type + "." + light.name,
                            "value":"offline",
                            "icon status" : {"bu-fill":{"fill":"transparent"},"bu-not-present":{"opacity":1}}}})
                
        coro = self.loop.create_datagram_endpoint(
                  partial(aiolifx.LifxDiscovery,self.loop, parent=self, ipv6prefix=self.config["ipv6prefix"],discovery_interval=self.lifx_config["refresh"]), local_addr=('0.0.0.0', UDP_BROADCAST_PORT))
        self.probelights = self.loop.create_task(coro)

    #This is a call back, so we need the right signature
    def newbulb(self,alight,xx):
        alight.name=self.subtype+"-"+alight.mac_addr.replace(":","")
        alight.nickname=alight.label
        notseen =  True
        for light in self.devices:
            ispresent=False 

            if alight.name == light.name:
                light.conn=alight
                light.controller = self
                ispresent=True
                if ispresent != light.present:
                    light.present = ispresent
                    self.sending({"subject":self.type,
                        "content_type": "event",
                        "content":{"event":"presence", 
                                   "target":self.type + "." + light.name,
                                    "value":ispresent and "online" or "offline",
                                    "icon status" : {"bu-fill":{"fill":(ispresent and light.cssColour()) or "transparent"},
                                                     "bu-not-present":{"opacity":(not ispresent and 1) or 0}}}})
                notseen=False
                break
        if notseen:
            self.pending.append(alight)
            self.sending({"subject":"control" + "." + self.type,
                      "content_type": "request",
                      "content":{"request":"creation", 
                                 "target":self.type, #Here we need the type
                                 #"token": self.target,
                                 "value":{"name":alight.name, "nickname":alight.nickname or alight.name,"subtype":self.subtype}}})
        else:
            self.lifxhb[self.subtype]=self.loop.call_later(self.lifx_config["heartbeat"]+random.randrange(int(self.lifx_config["heartbeat"])), partial(light.lighthb,self.lifx_config["heartbeat"]))
            
    def register(self,alight):
        alight.log=self.log
        xx=alight.get_color(callb=partial(self.newbulb))
        
    def unregister(self,alight):
        if alight in self.pending:
            self.pending.remove(alight)
        else:
            try:
                self.lifxhb[alight.name].cancel()
                #print ("HB Canceled for {}".format(alight.label))
            except:
                pass
            for light in self.devices:
                try: #HAve to protect, in some rare cases, alight does not have a name attribute yet
                    if light.name == alight.name:
                        light.conn = None
                        light.present = False
                        self.sending({"subject":self.type ,
                                    "content_type": "event",
                                    "content":{"event":"presence", 
                                            "target": self.type + "." + light.name,
                                            "value":"offline",
                                            "icon status" : {"bu-fill":{"fill":"transparent"},
                                                             "bu-not-present":{"opacity":1}}}})
                except:
                    pass

aboutstr="""<p>LifxBuddy is a bridge talking to <a href="http://www.lifx.com">Lifx</a> lights. A library called <a href="https://github.com/frawau/aiolifx">aiolifx</a>
 is used when communicating with the actual device.</p>
<p>The icon used to represent Lifx devices has been lifted and adapted from <a href="https://fortawesome.github.io/Font-Awesome">Font Awesome</a>
<i class=\"fa fa-flag-o \">These guys rock!</i></p>
<p class=\"bu-copyright\">&copy; 2017 Fran&ccedil;ois Wautier</p>
"""

iconstr="""
   <svg class="bu-device-icon" width="60" height="60" viewBox="0 0 1792 1792" xmlns="http://www.w3.org/2000/svg">
     <path class="bu-shape" d="M1120 576q0 13-9.5 22.5t-22.5 9.5-22.5-9.5-9.5-22.5q0-46-54-71t-106-25q-13 0-22.5-9.5t-9.5-22.5 9.5-22.5 
                               22.5-9.5q50 0 99.5 16t87 54 37.5 90zm160 0q0-72-34.5-134t-90-101.5-123-62-136.5-22.5-136.5 22.5-123 62-90 
                               101.5-34.5 134q0 101 68 180 10 11 30.5 33t30.5 33q128 153 141 298h228q13-145 141-298 10-11 30.5-33t30.5-33q68-79
                               68-180zM1400 576q0 155-103 268-45 49-74.5 87t-59.5 95.5-34 107.5q47 28 47 82 0 37-25 64 25 27 25 64 0 52-45 
                               81 13 23 13 47 0 46-31.5 71t-77.5 25q-20 44-60 70t-87 26-87-26-60-70q-46 0-77.5-25t-31.5-71q0-24 13-47-45-29-45-81
                               0-37 25-64-25-27-25-64 0-54 47-82-4-50-34-107.5t-59.5-95.5-74.5-87q-103-113-103-268 0-99 44.5-184.5t117-142 
                               164-89 186.5-32.5 186.5 32.5 164 89 117 142 44.5 184.5z"/>
     <path class="bu-fill" d="M1120 576q0 13-9.5 22.5t-22.5 9.5-22.5-9.5-9.5-22.5q0-46-54-71t-106-25q-13 0-22.5-9.5t-9.5-22.5 9.5-22.5 
                              22.5-9.5q50 0 99.5 16t87 54 37.5 90zm160 0q0-72-34.5-134t-90-101.5-123-62-136.5-22.5-136.5 22.5-123 62-90 
                              101.5-34.5 134q0 101 68 180 10 11 30.5 33t30.5 33q128 153 141 298h228q13-145 141-298 10-11 30.5-33t30.5-33q68-79 
                              68-180z" fill="transparent"/>
    <path class="bu-not-present" fill="#a94442" 
           d="M1440 893q0-161-87-295l-754 753q137 89 297 89 111 0 211.5-43.5t173.5-116.5 116-174.5 43-212.5zm-999 299l755-754q-135-91-300-91-148
              0-273 73t-198 199-73 274q0 162 89 299zm1223-299q0 157-61 300t-163.5 246-245 164-298.5 61-298.5-61-245-164-163.5-246-61-300 61-299.5 
              163.5-245.5 245-164 298.5-61 298.5 61 245 164 163.5 245.5 61 299.5z"/>
   </svg>
"""
cfgdefault={"type":"light","subtype":SUBTYPE,"host":"localhost","port":8745,"credential":"","ssl":""}
def configure(): 
    parser = argparse.ArgumentParser(description="Track Lifx light bulbs.")
    #                            version="%prog " + __version__ + "/" + bl.__version__)
    parser.add_argument("-t", "--type", default=cfgdefault["type"],
                    help="The type of devices we handle. (default  \"%s\")." % cfgdefault["type"])
    parser.add_argument("-s", "--subtype", default=cfgdefault["subtype"],
                    help="The specific subtype we manage. (default  \"%s\")." % cfgdefault["subtype"])
    parser.add_argument("-a", "--host", default=cfgdefault["host"],
                    help="The host address of the server (default \"%s\")." % cfgdefault["host"])
    parser.add_argument("-p", "--port", type=int, default=cfgdefault["port"],
                    help="The port used by the server (default \"%s\")." % cfgdefault["port"])
    parser.add_argument("-c", "--config", default="/etc/autobuddy/lifx.cfg", type=argparse.FileType('r'),
                    help="Config file to use (default \"/etc/autobuddy/lifx.cfg\")")
    parser.add_argument("-V", "--credential", default=cfgdefault['credential'],
                    help="The credential used to verify authorization (default \"%s\")." % cfgdefault["credential"])
    parser.add_argument("-6", "--ipv6prefix", default=False,
                    help="Connect to Lifx using IPv6 with given /64 prefix (Do not end with colon unless you have less than 64bits).")
    parser.add_argument("-d", "--debug", action="count", default=0,
                    help="Log debug information (default False)")
    parser.add_argument("-S", "--ssl", default="",
                    help="The directory where the file %s can be found."%(CERTFILE))
    parser.add_argument("-v", "--verbose", action="store_true", default=False,
                    help="Log warning messages")
    parser.add_argument("-C", "--configonly", default="",
                    help="Exit after the the configuration has been saved")
    
    try:
        opts=parser.parse_args()
    except Exception as e:
        parser.error("Error: "+str(e))
        
    if opts.debug:
        logging.basicConfig(
            level=logging.DEBUG,
            format='%(levelname)7s: %(message)s',
            stream=sys.stderr,
            )
    elif opts.verbose:
        logging.basicConfig(
            level=logging.WARNING,
            format='%(levelname)7s: %(message)s',
            stream=sys.stderr,
            )
    else:
        logging.basicConfig(
            level=logging.CRITICAL,
            format='%(levelname)7s: %(message)s',
            stream=sys.stderr,
            )
    lightlog = logging.getLogger('')
    lifxcfg = {"debug":opts.debug}
    try:
    #if True:
        if opts.configonly:
            try:
                cfgdata = json.load(opts.config)
                opts.config.close()
            except:
                cfgdata={}
        else:
            cfgdata = json.load(opts.config)
            opts.config.close()
        if opts.type != cfgdefault["type"]:
            lifxcfg["type"] = opts.type
        elif "type" in cfgdata:
            lifxcfg["type"] = cfgdata["type"]     
        else:
            lifxcfg["type"] = opts.type
        if opts.debug:
            lightlog.debug("The type is %s." % lifxcfg["type"])
            
        if opts.subtype != cfgdefault["subtype"]:
            lifxcfg["subtype"] = opts.subtype
        elif "subtype" in cfgdata:
            lifxcfg["subtype"] = cfgdata["subtype"]     
        else:
            lifxcfg["subtype"] = opts.subtype
        if opts.debug:
            lightlog.debug("The subtype is %s." % lifxcfg["subtype"]) 
            
        if opts.credential != cfgdefault["credential"]:
            lifxcfg["credential"] = opts.credential
        elif "credential" in cfgdata:
            lifxcfg["credential"] = cfgdata["credential"]
        else:
            lifxcfg["credential"] = cfgdefault["credential"]
        if opts.debug:
            lightlog.debug("The credential is %s"%lifxcfg["credential"])       
            
        if opts.ipv6prefix:
            lifxcfg["ipv6prefix"] = opts.ipv6prefix
        elif "ipv6prefix" in cfgdata:
            lifxcfg["ipv6prefix"] = cfgdata["ipv6prefix"]
        else:
            lifxcfg["ipv6prefix"] = opts.ipv6prefix
        if opts.debug:
            lightlog.debug("The IPv6 prefix is %s"%lifxcfg["ipv6prefix"])
            
        if opts.port != cfgdefault["port"]:
            lifxcfg["port"] = opts.port
        elif "port" in cfgdata:
            lifxcfg["port"] = cfgdata["port"]
        else:
            lifxcfg["port"] = cfgdefault["port"]
        if opts.debug:
            lightlog.debug("The port is %s" % (lifxcfg["port"]))
            
        if opts.host != cfgdefault["host"]:
            lifxcfg["host"] = opts.host
        elif "host" in cfgdata:
            lifxcfg["host"] = cfgdata["host"]
        else:
            lifxcfg["host"] = cfgdefault["host"]
        if opts.debug:
            lightlog.debug("The host is %s"%lifxcfg["host"])       
 
        if "buddykey" in cfgdata:
            lifxcfg["buddykey"] = cfgdata["buddykey"]

        if opts.ssl != cfgdefault["ssl"]:
            lifxcfg["ssl"] = opts.ssl
        elif "ssl" in cfgdata:
            lifxcfg["ssl"] = cfgdata["ssl"]
        else:
            lifxcfg["ssl"] = cfgdefault["ssl"]
        if lifxcfg["ssl"] and not ( os.path.isfile(lifxcfg["ssl"]+"/"+CERTFILE)):
            lightlog.critical("Encryption: Could not find {} .".format(
                lifxcfg["ssl"]+"/"+CERTFILE))
            sys.exit()
        if opts.debug:
            if lifxcfg["ssl"]:
                lightlog.debug("The ssl certificates can be found in %s"%lifxcfg["ssl"]) 
            else:
                lightlog.debug("The connection is not encrypted") 
                    
        if opts.configonly:

            if "buddykey" not in lifxcfg:
                if opts.debug:
                    lightlog.debug("Generating random key")   
                lifxcfg["buddykey"] = bl.keygen()
            try:
                del(lifxcfg["debug"])
            except:
                pass
            with open(opts.configonly,"w") as cfile:
                json.dump(lifxcfg,cfile)
            os.chmod(opts.configonly,384) # 0600
            sys.exit()
        
    except Exception as e:
        lightlog.error("Error: %r" % e)
        sys.exit(-2)
    
    return (lightlog,lifxcfg)

         
if __name__ == "__main__":
    log,config=configure()
    log.info("Configured")
    loop = aio.get_event_loop()
    if config["debug"]:
        loop.set_debug(True)
    if config["ssl"]:
        sslcontext = ssl.create_default_context(ssl.Purpose.SERVER_AUTH,
            cafile=config["ssl"]+'/'+CERTFILE)
        
        sslcontext.check_hostname = False
    else:
        sslcontext=None
    connFuture=aio.Future()
    fac=loop.create_connection(functools.partial(LifxBridge,loop,connFuture,config,log),config["host"], config["port"],ssl=sslcontext)
    conn,bridgectl = loop.run_until_complete(fac)
    loop.call_soon(bridgectl.configrequest,{"about":{"LifxBuddy":aboutstr},"display":{"Lifx":iconstr}})

    try:
        loop.run_until_complete(connFuture)
    except  KeyboardInterrupt:
        print("\n","Exiting at user's request")
    finally:
        for x in bridgectl.lifxhb.values():
            x.cancel()
        bridgectl.probelights.cancel()
        conn.close()
        loop.close()

            
    