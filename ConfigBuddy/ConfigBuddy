#!/usr/bin/env python3
# -*- coding:utf-8 -*-
#
# This application is used to configure an AutoBuddy appliance
# 
# Copyright (c) 2015 Fran√ßois Wautier
#
# Permission is hereby granted, free of charge, to any person obtaining a copy 
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
# of the Software, and to permit persons to whom the Software is furnished to do so,
# subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all copies
# or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
# WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
# IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE
import subprocess,os,json,sys,glob

from collections import defaultdict
from getpass import getpass
import buddylib as bl
from urllib.request import urlopen

debug=False

#BUDDYLOCATION="/home/autobuddy/AutoBuddy"
BUDDYLOCATION="/".join(os.path.realpath(__file__).split("/")[:-2])
currentowner=os.stat(BUDDYLOCATION)

def passgen():
    from random import shuffle,randrange
    lolet=list("0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ-_*.?")
    for i in range(5):
        shuffle(lolet)
    lolet *= 100
    for i in range(20):
        shuffle(lolet)
    startidx=randrange(len(lolet)-16)
    return "".join(lolet[startidx:startidx+16])

def keygen():
    from random import shuffle,randrange
    lolet=list("0123456789aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ`~!@#$%^&*()_+-|\[{]}?/.,<:;")
    for i in range(5):
        shuffle(lolet)
    lolet *= 1000
    for i in range(20):
        shuffle(lolet)
    startidx=randrange(len(lolet)-32)
    return "".join(lolet[startidx:startidx+32])


#This is basically a linear walk-through the needed settings...
mylocation={"timezone":"Europe/Paris","lat":48.8584,"lon":2.2945,"countryCode":"FR","regionName":"Paris","city":"Paris"}
try:
    mylocation=json.loads(urlopen("http://ip-api.com/json").read().decode())
except:
    pass

#Starting with time zone
print("\n\nWelcome to AutoBuddy configuration tool.\nWe have been trying to figure out your location")
print("\nWe will start by updating your time zone.")
gotit=False
while not gotit:
    print ("\n\nOK, me think your time zone is %s"%mylocation["timezone"])
    for x in ["Yes","No"]:
        print("\t %s"%x)
    print()
    choice = input(" Your choice: ")
    try:
        if choice.strip().lower() in ['y',"yes","yay","sure","yep","affirmative"]:
            gotit=True
            choice=mylocation["timezone"]
        elif choice.strip().lower() in ['n','no','nope','nay','negative','wrong']:
            gotit=True
            choice=""
        else:
            raise Exception
    except:
        os.system('clear')
        print ("\n\nInput not recognized. Please pay attention.")
        
if not choice:    
    print ("\n\nOoops, I got it wrong, my bad! Let's try another way.")
    lotz=subprocess.check_output(["timedatectl", "--no-pager","list-timezones"]).decode()
    tzlist=defaultdict(list)
    for rawzone in lotz.split("\n"):
        if not rawzone:
            continue
        zone=rawzone.split("/")
        if len(zone) == 1:
            tzlist[zone[0]]=None
        else:
            tzlist[zone[0]].append("/".join(zone[1:]))        
    lotopz=list(tzlist.keys())
    lotopz.sort()
    os.system('clear')
    gotit=False
    mode="init"
    weredone=False
    while not weredone:
        if mode=="init":
            while not gotit:
                idx=0
                print ("\n\nPlease do select the number corresponding to your time zone")
                for x in lotopz:
                    print ("   %d\t %s"%(idx,x))
                    idx+=1
                print()
                choice = input(" Your choice: ")
                try:
                    choice=int(choice)
                    if choice < 0 or choice >= len(lotopz):
                        raise Exception
                    gotit=True
                except:
                    os.system('clear')
                    print ("\n\nInput not recognized. Please pay attention.")
                    
        mode="sub"
        os.system('clear')
        topzone=lotopz[choice]    
        if tzlist[topzone]:
            #Find more
            sidx=0
            maxidx=10
            gotit=False
            while not gotit:
                print ("\n\n\nPlease do select the number corresponding to your time zone")
                idx=0
                while idx< min(maxidx,len(tzlist[topzone])-sidx):
                    print ("   %d\t %s/%s"%(idx,topzone,tzlist[topzone][sidx+idx]))
                    idx+=1
                print ("\n\nUse 'b' to go back to the previous screen. 'n' to go to the next one.\n")
                choice = input(" Your choice: ")
                try:
                    if choice.strip().lower()=='b':
                        if sidx == 0:
                            mode="init"
                            os.system('clear')
                            break
                        else:
                            sidx-=maxidx
                            os.system('clear')
                    elif choice.strip().lower()=='n':
                        if sidx+maxidx < len(tzlist[topzone]):
                            sidx+=maxidx
                        os.system('clear')
                    else:
                        choice=int(choice)
                        if choice < 0 or choice >= min(maxidx,len(tzlist[topzone])-sidx):
                            raise Exception
                        gotit=True
                        weredone=True
                        choice=topzone+"/"+tzlist[topzone][choice+sidx]
                except:
                    os.system('clear')
                    print ("Input not recognized. Please pay attention.")
                        
                    
if debug:
    print ("We got %s"%choice)
else:
    lotz=subprocess.check_output(["timedatectl", "set-timezone",choice])    

os.system('clear')
print("\n\n\n\n Time zone was set to %s"%choice)
choice = input(" Press '<enter>' to continue")

os.system('clear')
print("\n\n\n\nNow we shall install the packages we need... You had better be on Debian with apt for this to work")
choice = input(" Press '<enter>' to proceed")
try:
    subprocess.run(["apt","-y","install","postgresql","python3-sqlalchemy","python3-crypto","python3-psycopg2","python3-aiohttp"])
    print("Allright, it looks like we are done.")
except:
    print("Something wrong just happened....Let's continue anyway. Danger is my middle name")
choice = input(" Press '<enter>' to continue")


os.system('clear')
print("\n\n\n\nNow we shall install all the bits needed and packaged in a tar file.")
choice = input(" Press '<enter>' to proceed")
try:
    subprocess.run(["tar","xvfj",BUDDYLOCATION+"/alltherest.tar.bz2","-C", BUDDYLOCATION])
    print("Allright, it looks like we are done.")
except:
    print("Something wrong just happened....Let's continue anyway. Danger is my middle name")
choice = input(" Press '<enter>' to continue")


os.system('clear')
weredone=False
newpasswd=""
while not weredone:
    print ("\n\n\n We will now set a new password for the default user 'autobuddy'.\n\n")
    passwd = getpass(" Password: ")
    confirm = getpass(" Confirm Password: ")
    if passwd == confirm :
        weredone = True
        newpasswd=passwd
    else:
        os.system('clear')
        print ("\n\n The passwords did not match.")

if debug:
    print ("New password is %d"%newpasswd)
else:
    chpass=subprocess.Popen(["chpasswd"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
    d_out=chpass.communicate(input="autobuddy:%s"%newpasswd)[0]
    
    
os.system('clear')
print ("\n\n\n\n Password was set.\n\n")
choice = input(" Press '<enter>' to continue")

createdb="CREATE DATABASE autobuddy ENCODING 'UTF8';"
pgreadonlyuser="""
CREATE USER readbuddy WITH ENCRYPTED PASSWORD '%s';
GRANT CONNECT ON DATABASE autobuddy TO readbuddy;
GRANT USAGE ON SCHEMA public TO readbuddy;
GRANT SELECT ON ALL SEQUENCES IN SCHEMA public TO readbuddy;
GRANT SELECT ON ALL TABLES IN SCHEMA public to readbuddy;
ALTER DEFAULT PRIVILEGES IN SCHEMA public GRANT SELECT ON TABLES TO readbuddy;
"""
pgmainuser="""
CREATE USER autobuddy WITH ENCRYPTED PASSWORD '%s';
GRANT ALL PRIVILEGES ON DATABASE autobuddy TO autobuddy;
"""

os.system('clear')
weredone=False
newpasswd=""
while not weredone:
    print ("\n\n\n We will now create and set a password for the \"autobuddy\"  user in PostgreSQL.\n This user has all access to the \"autobuddy\" database.\n\n")
    print (" If you leave the password empty, I will generate the password automatically.\n\n")
    passwd = getpass(" Password: ")
    if passwd:
        confirm = getpass(" Confirm Password: ")
        if passwd == confirm :
            weredone = True
            dbpasswd=passwd
        else:
            os.system('clear')
            print ("\n\n The passwords did not match.")
    else:
        dbpasswd=passgen()
        weredone = True
    
    
os.system('clear')    
weredone=False
newpasswd=""
while not weredone:
    print ("\n\n\n We will now create and set a password for the \"readbuddy\"  user in PostgreSQL.\n This user has read-only access to the \"autobuddy\" database.\n\n")
    print (" If you leave the password empty, I will generate the password automatically.\n\n")
    passwd = getpass(" Password: ")
    if passwd:
        confirm = getpass(" Confirm Password: ")
        if passwd == confirm :
            weredone = True
            ropasswd=passwd
        else:
            os.system('clear')
            print ("\n\n The passwords did not match.")
    else:
        ropasswd=passgen()
        weredone = True
          
#of=file("/tmp/cmd.sql","w")
#of.write("ALTER USER autobuddy PASSWORD '%s';\n"%dbpasswd)
#of.write("ALTER USER readbuddy PASSWORD '%s';\n"%ropasswd)
newconfig=createdb+pgmainuser%dbpasswd + pgreadonlyuser%ropasswd
if debug:
    print ("New passwords are {} and {}.".format(dbpasswd,ropasswd))
else:
    chpass=subprocess.Popen(["sudo", "-u", "postgres", "/usr/bin/psql"], stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE,universal_newlines=True)
    d_out=chpass.communicate(input=newconfig)
    
os.system('clear')
print("\n\n\n\n Database was created, so were users and passwords were set.\n\n")
choice = input(" Press '<enter>' to continue")
    
os.system('clear')
print ("\n\n\n\n Last but not least, I need to know the name of the top zone.\n\n")
choice = input(" Top Zone Name [Home]: ")
if not choice:
    topzone="Home"
else:
    topzone=choice
 
os.system('clear')
print ("\n\n\n\n Thank you, I will now proceed and finalize the configuration before asking you what to run.\n\n")
choice = input(" Press '<enter>' to continue")
   
certdir=BUDDYLOCATION+"/.tls"
try:
    os.mkdir(certdir,mode=0o700)
except FileExistsError:
    pass

os.chown(certdir,currentowner.st_uid,currentowner.st_gid)

try:
    os.mkdir(BUDDYLOCATION+"/.buddyconfig",mode=0o700)
except FileExistsError:
    pass

os.chown(BUDDYLOCATION+"/.buddyconfig",currentowner.st_uid,currentowner.st_gid)

try:
    os.mkdir(BUDDYLOCATION+"/.run",mode=0o700)
except FileExistsError:
    pass

os.chown(BUDDYLOCATION+"/.run",currentowner.st_uid,currentowner.st_gid)


subj="/C=%s/ST=%s/L=%s/O=AutoBuddy Security/OU=Home Security/CN=autobuddy.local"%(mylocation["countryCode"],mylocation["regionName"],mylocation["city"])

subprocess.run(["openssl", "req", "-x509", "-nodes", "-days", "7300", "-newkey", "rsa:2048", "-keyout", BUDDYLOCATION+"/.tls/autobuddy.key", "-out",
                BUDDYLOCATION+"/.tls/autobuddy.crt", "-subj", subj])
print("Self-signed certificate was created")

os.chown(BUDDYLOCATION+"/.tls/autobuddy.key",currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/.tls/autobuddy.key",0o600)
os.chown(BUDDYLOCATION+"/.tls/autobuddy.crt",currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/.tls/autobuddy.crt",0o600)

credential=passgen()
print ("Credential will be {}.".format(credential))
mycfg={}
mycfg["zone"]=topzone
mycfg["database"] = {"db": "autobuddy", "host": "localhost", "driver": "postgres", "user": "autobuddy","password":dbpasswd}
mycfg["dbronly"] = {"user": "readbuddy","password":ropasswd}
mycfg["type"] = "control"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()

controlkey=mycfg["buddykey"]

fn=BUDDYLOCATION+"/.buddyconfig/config.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/ControlBuddy/ControlBuddy",0o775)
mycmd="""#!/bin/bash
while [ 1 ]; do
    """
mycmd+=BUDDYLOCATION+"/ControlBuddy/ControlBuddy -c "+fn
mycmd+="\n    sleep 10\ndone\n"
fn=BUDDYLOCATION+"/.run/01-control"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
bustartcmd="#!/bin/bash\ntmux new-session -s AutoBuddy -d "+fn

print ("Stlll working!")

mycfg={}
mycfg["tls"]=certdir
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
mycfg["application"] = BUDDYLOCATION+"/WebBuddy/buddyctrl.html"
mycfg["host"] = "autobuddy.local"
mycfg["port"] = 8090
mycfg["type"] = ["guibridge"]
mycfg["broker"] = ["localhost"]


fn=BUDDYLOCATION+"/.buddyconfig/websocket.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/SocketBuddy/SocketBuddy",0o775)
mycmd="""#!/bin/bash
while [ 1 ]; do
    sleep 12
"""
mycmd+=BUDDYLOCATION+"/SocketBuddy/SocketBuddy -c "+fn
mycmd+="\ndone\n"
fn=BUDDYLOCATION+"/.run/99-socket"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
bustartcmd+="\ntmux new-window -t AutoBuddy -d "+fn

print ("Stlll working!")

mycfg={}
mycfg["host"]= "localhost"
mycfg["type"] = "light"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()

fn=BUDDYLOCATION+"/.buddyconfig/lifx.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/LifxBuddy/LifxBuddy",0o775)
mycmd="""#!/bin/bash
while [ 1 ]; do
    sleep 10
"""
mycmd+=BUDDYLOCATION+"/LifxBuddy/LifxBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/30-lifx"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
bustartcmd+="\ntmux new-window -t AutoBuddy -d "+fn

print ("Patience!")


mycfg={}
mycfg["host"]= "localhost"
mycfg["type"] = "switch"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()
mycfg["flichost"] = "localhost"
mycfg["flicpath"] = BUDDYLOCATION + "/FlicBuddy/flicd/"

fn=BUDDYLOCATION+"/.buddyconfig/flic.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/FlicBuddy/FlicBuddy",0o775)
mycmd="""#!/bin/bash
while [ 1 ]; do
    sleep 10
"""
mycmd+=BUDDYLOCATION+"/FlicBuddy/FlicBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/30-flic"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
bustartcmd+="\ntmux new-window -t AutoBuddy -d "+fn

print ("Just a little longer!")

mycfg={}
mycfg["host"]= "localhost"
mycfg["type"] = "action"
mycfg["credential"] = credential
mycfg["ssl"]=certdir
mycfg["buddykey"] = keygen()

fn=BUDDYLOCATION+"/.buddyconfig/action.cfg"
with open(fn,"w") as cfile:
    json.dump(mycfg,cfile)
os.chmod(fn,0o600)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(BUDDYLOCATION+"/ActionBuddy/ActionBuddy",0o775)
mycmd="""#!/bin/bash
while [ 1 ]; do
    sleep 10
"""
mycmd+=BUDDYLOCATION+"/ActionBuddy/ActionBuddy -c "+fn
mycmd+="\n    sleep 2\ndone\n"
fn=BUDDYLOCATION+"/.run/50-action"
with open(fn,"w") as cfile:
    cfile.write(mycmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)
bustartcmd+="\ntmux new-window -t AutoBuddy -d "+fn


fn=BUDDYLOCATION+"/.start-autobuddy"
with open(fn,"w") as cfile:
    cfile.write(bustartcmd)
os.chown(fn,currentowner.st_uid,currentowner.st_gid)
os.chmod(fn,0o750)


mycfg["database"] = {"db": "autobuddy", "host": "localhost", "driver": "postgres", "user": "autobuddy","password":dbpasswd}

bdb = mycfg["database"]["driver"] + "://"
if "user" in mycfg["database"] and mycfg["database"]["user"]:
    bdb += mycfg["database"]["user"] + ":" + mycfg["database"]["password"] + "@"
bdb += mycfg["database"]["host"]

if "port" in mycfg["database"] and mycfg["database"]["port"]:
    bdb += ":"+ str(mycfg["database"]["port"])
bdb += "/" + mycfg["database"]["db"]

print ("Almost there!")

#print "Connecting with",bdb
sess=bl.getSession(bdb)
bl.initialize(sess)
nzone=bl.Zone()
nzone.name="zone-BuddyRoot"
nzone.nickname=topzone
sess.add(nzone)
nprop=bl.BuddyProperty()
nprop.entity="guibridge"
nprop.name="users"
nprop.values=bl.encrypt({"admin":["password","admin"]},mycfg["buddykey"])
sess.add(nprop)
nprop=bl.BuddyProperty()
nprop.entity="System"
nprop.name="configuration"
nprop.values=bl.encrypt({"location":{"longitude":mylocation["lon"],"latitude":mylocation["lat"],"altitude":4}},controlkey)
sess.add(nprop)
sess.commit()



for fname in glob.glob(BUDDYLOCATION + "/FlicBuddy/flicd/flicd.*") :
    subprocess.run(["/sbin/setcap", "cap_net_admin=ep", fname])

print ("\n\n\n\n We are done. We are about to reboot. \n\n After reboot, point your browser to https://autobuddy.local:8090/.\n\n Login with username \"admin\" and password \"password\".")
print ("\nIf you plan to connect remote buddies, you'll need enable remote access to PostgreSQL\nand use the credential {}".format(credential))
choice = input(" Press '<enter>' to reboot")
#os.system("reboot")